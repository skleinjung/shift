import { map as mapI } from 'lodash'
import { compact, filter, forEach, join, map, omit, values } from 'lodash/fp'
import { TypedEventEmitter } from 'typed-event-emitter'

import { DoNothing } from './actions/do-nothing'
import { getResultMessage } from './actions/result-handler'
import { AttackResult } from './combat'
import { Creature } from './creature'
import { CreatureTypes } from './creature-db'
import { createDungeon } from './dungeon/create-dungeon-v1'
import { WorldEvents } from './events'
import { createArmor, createWeapon, Item } from './item'
import { ExpeditionMap } from './map'
import { Player } from './player'
import { Action } from './types'

export class World extends TypedEventEmitter<WorldEvents> {
  public readonly map = new ExpeditionMap()
  public readonly creatures: Record<number, Creature> = {}

  // all player-readable log messages from this game
  private _messages: string[] = []

  private _player: Player
  private _playerAction: Action

  constructor () {
    super()

    // eslint-disable-next-line no-console
    console.log('>>>>>>>>>>>> New World')

    const dungeon = createDungeon()
    dungeon.createTerrain(this.map)
    forEach((spawn) => {
      this._registerCreature(new Creature(CreatureTypes[spawn.type], spawn.x, spawn.y, this.map))
    }, dungeon.creatures)

    this._player = new Player(CreatureTypes.player, 0, 0, this.map)
    this._registerCreature(this._player)
    this._playerAction = DoNothing
    this._player.inventory.addItem(new Item({ name: 'a coconut' }))
    this._player.inventory.addItem(new Item({ name: 'hopes and dreams' }))

    const spear = createWeapon('+100 spear', 100)
    this._player.inventory.addItem(spear)
    // this._player.equip(spear)

    const armor = createArmor('amazing, glowing armor', 100, `Lorem ipsum dolor sit amet, 
consectetur adipiscing elit. Aenean pharetra est id velit laoreet, eu semper lectus ullamcorper.
Nunc pellentesque nunc ex, eu venenatis orci mattis non. Maecenas in justo mollis, luctus urna 
porttitor, imperdiet lectus. Quisque sit amet quam venenatis, iaculis sapien in, rutrum dui.`)
    this._player.inventory.addItem(armor)
    // this._player.equip(armor)

    this.map.addItem(-2, 0, createWeapon('+1 spear', 1))
    this.map.addItem(2, 0, createWeapon('+2 spear', 2))
    this.map.addItem(2, 0, createWeapon('+3 spear', 3))

    this.logMessage('Expedition started.')
  }

  /**
   * Appends a message to the player's log.
   */
  public logMessage (message: string) {
    this._messages.push(message)
    this.emit('message', message)
  }

  /**
   * Gets the creature with a specified ID. If there is no creature with that ID, will return undefined.
   */
  public getCreature (id: number) {
    return this.creatures[id]
  }

  /**
   * Submit the player's next action, and update the world state for the next turn.
   */
  public nextTurn (playerAction: Action) {
    this._playerAction = playerAction

    // iterate over each creature, and get the action determined by its behavior
    const actions = map((creature) => creature.type.behavior(creature, this), this.creatures)

    // once all actions have been determined, execute them
    // TODO: examine success/failure return value
    forEach((action) => {
      const result = action.execute(this)

      const message = getResultMessage(result)
      if (message !== undefined) {
        this.logMessage(message)
      }
    }, compact(actions))

    // remove any dead creatures
    const deadCreatures = filter((creature) => creature.dead, values(this.creatures))
    forEach((creature) => {
      delete this.creatures[creature.id]
      this.logMessage(`${creature.type.name} is dead!`)
      this.map.removeCreature(creature)
    }, deadCreatures)

    this.emit('turn')
  }

  /** Returns flag indicating if the current expedition reached an end condition. */
  public get expeditionEnded () {
    return this.player.link < 1 || this.player.dead
  }

  /**
   * Gets all messages generated by this world so far.
   */
  public get messages () {
    return this._messages
  }

  public get player () {
    return this._player
  }

  /** Gets the action being performed by the player in the current turn. */
  public get playerAction () {
    return this._playerAction
  }

  /** Adds the results of an attack to the message log. */
  private _logAttack (attack: AttackResult) {
    if (attack.success) {
      // we don't display 'overkill' or 'taken' damage broken out for the user
      const damages = mapI(omit(['overkill', 'taken'], attack.damage), (value, type) => `${value} ${type}`)
      const damagesString = damages.length === 0
        ? ''
        : ` (${join(', ', damages)})`

      this.logMessage(
        `${attack.attacker.name} hits ${attack.target.name} for ${attack.damageRolled} damage.${damagesString}`
      )
    } else {
      this.logMessage(`${attack.attacker.name} misses ${attack.target.name}.`)
    }
  }

  /**
   * Registers a newly created by creature with the world.
   */
  private _registerCreature (creature: Creature) {
    this.creatures[creature.id] = creature

    creature.on('attack', this._logAttack.bind(this))
  }
}
