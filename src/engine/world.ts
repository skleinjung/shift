import { map as mapI } from 'lodash'
import { compact, filter, forEach, join, map, omit, values } from 'lodash/fp'
import { TypedEventEmitter } from 'typed-event-emitter'

import { NoopAction } from './actions/noop'
import { AttackResult } from './combat'
import { Creature } from './creature'
import { CreatureTypeId, CreatureTypes } from './creature-db'
import { createDungeon } from './dungeon/create-dungeon-v1'
import { WorldEvents } from './events'
import { createArmor, createWeapon, Item } from './item'
import { ExpeditionMap } from './map'
import { Action } from './types'

export class World extends TypedEventEmitter<WorldEvents> {
  public readonly map = new ExpeditionMap()
  public readonly creatures: Record<number, Creature> = {}

  // all player-readable log messages from this game
  private _messages: string[] = []

  private _player: Creature
  private _playerAction: Action

  constructor () {
    super()

    const dungeon = createDungeon()
    dungeon.createTerrain(this.map)
    forEach((spawn) => {
      this.spawn(spawn.type, spawn.x, spawn.y)
    }, dungeon.creatures)

    this._player = this.spawn('player', 0, 0)
    this._playerAction = NoopAction
    this._player.inventory.add(new Item({ name: 'a coconut' }))
    this._player.inventory.add(new Item({ name: 'hopes and dreams' }))

    const spear = createWeapon('+100 spear', 100)
    this._player.inventory.add(spear)
    // this._player.equip(spear)

    const armor = createArmor('amazing, glowing armor', 100, `Lorem ipsum dolor sit amet, 
consectetur adipiscing elit. Aenean pharetra est id velit laoreet, eu semper lectus ullamcorper.
Nunc pellentesque nunc ex, eu venenatis orci mattis non. Maecenas in justo mollis, luctus urna 
porttitor, imperdiet lectus. Quisque sit amet quam venenatis, iaculis sapien in, rutrum dui.`)
    this._player.inventory.add(armor)
    // this._player.equip(armor)

    this.map.addItem(-2, 0, armor)
    this.map.addItem(2, 0, spear)
    this.map.addItem(2, 0, armor)

    this.logMessage('Expedition started.')
  }

  /**
   * Appends a message to the player's log.
   */
  public logMessage (message: string) {
    this._messages.push(message)
    this.emit('message', message)
  }

  /**
   * Gets the creature with a specified ID. If there is no creature with that ID, will return undefined.
   */
  public getCreature (id: number) {
    return this.creatures[id]
  }

  /**
   * Submit the player's next action, and update the world state for the next turn.
   */
  public nextTurn (playerAction: Action) {
    this._playerAction = playerAction

    // iterate over each creature, and get the action determined by its behavior
    const actions = map((creature) => creature.type.behavior(creature, this), this.creatures)

    // once all actions have been determined, execute them
    forEach((action) => action(this), compact(actions))

    // remove any dead creatures
    const deadCreatures = filter((creature) => creature.dead, values(this.creatures))
    forEach((creature) => {
      delete this.creatures[creature.id]
      this.logMessage(`${creature.type.name} is dead!`)
      this.map.removeCreature(creature)
    }, deadCreatures)
  }

  /**
   * Creates a creature of a given type at a specific map location.
   */
  public spawn (creatureTypeId: CreatureTypeId, xLocation: number, yLocation: number) {
    const type = CreatureTypes[creatureTypeId]
    const creature = new Creature(type, xLocation, yLocation, this.map)
    this.creatures[creature.id] = creature

    creature.on('attack', this._logAttack.bind(this))

    return creature
  }

  /**
   * Gets all messages generated by this world so far.
   */
  public get messages () {
    return this._messages
  }

  public get player () {
    return this._player
  }

  /** Gets the action being performed by the player in the current turn. */
  public get playerAction () {
    return this._playerAction
  }

  /** Adds the results of an attack to the message log. */
  private _logAttack (attack: AttackResult) {
    if (attack.success) {
      // we don't display 'overkill' or 'taken' damage broken out for the user
      const damages = mapI(omit(['overkill', 'taken'], attack.damage), (value, type) => `${value} ${type}`)
      const damagesString = damages.length === 0
        ? ''
        : ` (${join(', ', damages)})`

      this.logMessage(
        `${attack.attacker.name} hits ${attack.target.name} for ${attack.damageRolled} damage.${damagesString}`
      )
    } else {
      this.logMessage(`${attack.attacker.name} misses ${attack.target.name}.`)
    }
  }
}
