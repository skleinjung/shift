import { flatten, map, times } from 'lodash/fp'

import { random } from './random'

export abstract class Generator<T> {
  constructor (
    /** number of instances of this outcome to generate, if it spawns at all (default: 1) */
    public readonly quantity = 1
  ) {
  }

  /** Collects the products from this node. */
  public collect (): T[] {
    return flatten(times(this.collectOne.bind(this), this.quantity))
  }

  /** Generate a single roll from this generator. Will be called repeatedly, based on quantity value. */
  protected abstract collectOne (): T[]
}

export interface PossibleResult<T> {
  chance: number
  result: Generator<T>
}

export class Product<T> extends Generator<T> {
  constructor (
    /** the result generated by this outcome */
    private readonly _result: T,
    /** number of instances of this outcome to generate, if it spawns at all (default: 1) */
    quantity = 1
  ) {
    super(quantity)
  }

  /** Generate a single roll from this generator. Will be called repeatedly, based on quantity value. */
  protected collectOne (): T[] {
    return [this._result]
  }
}

export class ProductGroup<T> extends Generator<T> {
  public static rollOne <T> (products: [number, Generator<T> | T][], quantity = 1) {
    const children = map(([chance, product]) => {
      const result = product instanceof Generator ? product : new Product(product)
      return { chance, result }
    }, products)

    return new ProductGroup<T>(children, quantity, false)
  }

  public static rollMany <T> (products: [number, Generator<T> | T][], quantity = 1) {
    const children = map(([chance, product]) => {
      const result = product instanceof Generator ? product : new Product(product)
      return { chance, result }
    }, products)

    return new ProductGroup<T>(children, quantity, true)
  }

  private constructor (
    /** children of this group */
    private _children: PossibleResult<T>[],
    /** number of instances of this outcome to generate, if it spawns at all (default: 1) */
    quantity: number,
    private _multiple: boolean
  ) {
    super(quantity)
  }

  protected collectOne (): T[] {
    const result = this._multiple
      ? this._rollAll()
      : this._rollOne()

    return result
  }

  private _rollAll (): T[] {
    return flatten(map((child) => random(0, 99) < child.chance ? child.result.collect() : [], this._children))
  }

  private _rollOne (): T[] {
    const roll = random(0, 99)
    let offset = 0
    for (const child of this._children) {
      if (roll - offset < child.chance) {
        return child.result.collect()
      }

      offset += child.chance
    }

    return []
  }
}
